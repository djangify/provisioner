"""
Nginx Configuration Manager

Generates and manages nginx reverse proxy configs for customer instances.
Each customer gets a subdomain like customer.djangify.com
"""

import os
import subprocess
from django.conf import settings
from .models import Instance, ProvisioningLog


class NginxManager:
    """
    Manages nginx configurations for eBuilder instances.

    Each instance gets a config like:
    /etc/nginx/conf.d/domains/ebuilder-janes-shop.conf
    """

    def __init__(self):
        self.config_dir = settings.NGINX_CONFIG_DIR
        self.base_domain = settings.BASE_DOMAIN
        self.server_ip = settings.SERVER_IP

    def log(self, instance, message):
        """Log nginx actions"""
        ProvisioningLog.objects.create(
            instance=instance,
            action="create",
            message=f"[NGINX] {message}",
        )

    def ensure_config_dir(self):
        """Ensure nginx config directory exists"""
        os.makedirs(self.config_dir, exist_ok=True)

    def get_config_path(self, instance):
        """Get the config file path for an instance"""
        return os.path.join(self.config_dir, f"ebuilder-{instance.subdomain}.conf")

    def generate_config(self, instance):
        """
        Generate nginx config for an instance.

        Handles:
        - Subdomain routing (always uses wildcard cert)
        - Custom domain (uses custom domain cert)
        - When custom domain is active, subdomain redirects to it
        - WebSocket support
        - Proxy headers
        """
        subdomain_host = f"{instance.subdomain}.{self.base_domain}"
        has_custom_domain = (
            instance.custom_domain
            and instance.custom_domain.strip()
            and instance.custom_domain_ssl
        )

        # Wildcard cert for subdomain
        wildcard_cert = settings.WILDCARD_SSL_CERT
        wildcard_key = settings.WILDCARD_SSL_KEY

        # Start config
        config = f"""# Auto-generated by eBuilder Provisioner
    # Instance: {instance.subdomain}
    # Customer: {instance.customer.email}
    # Generated: {instance.updated_at}

    upstream ebuilder_{instance.subdomain} {{
        server 127.0.0.1:{instance.port};
    }}

    # ===========================================
    # SUBDOMAIN: {subdomain_host}
    # ===========================================

    server {{
        listen {self.server_ip}:80;
        listen [::]:80;
        server_name {subdomain_host};

        # Redirect to HTTPS
        return 301 https://$host$request_uri;
    }}

    server {{
        listen {self.server_ip}:443 ssl;
        listen [::]:443 ssl;
        http2 on;
        server_name {subdomain_host};

        # SSL Configuration (wildcard cert)
        ssl_certificate {wildcard_cert};
        ssl_certificate_key {wildcard_key};
        ssl_session_timeout 1d;
        ssl_session_tickets off;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
    """

        if has_custom_domain:
            # Subdomain redirects to custom domain
            config += f"""
        # Redirect subdomain to custom domain
        return 301 https://{instance.custom_domain}$request_uri;
    }}
    """
        else:
            # Subdomain serves the site directly
            config += self._generate_proxy_block(instance)

        # Add custom domain server block if active
        if has_custom_domain:
            custom_domain_names = [instance.custom_domain]
            if not instance.custom_domain.startswith("www."):
                custom_domain_names.append(f"www.{instance.custom_domain}")

            custom_cert = (
                f"/etc/letsencrypt/live/{instance.custom_domain}/fullchain.pem"
            )
            custom_key = f"/etc/letsencrypt/live/{instance.custom_domain}/privkey.pem"

            config += f"""
    # ===========================================
    # CUSTOM DOMAIN: {instance.custom_domain}
    # ===========================================

    server {{
        listen {self.server_ip}:80;
        listen [::]:80;
        server_name {" ".join(custom_domain_names)};

        # Redirect to HTTPS
        return 301 https://{instance.custom_domain}$request_uri;
    }}

    server {{
        listen {self.server_ip}:443 ssl;
        listen [::]:443 ssl;
        http2 on;
        server_name {" ".join(custom_domain_names)};

        # SSL Configuration (custom domain cert)
        ssl_certificate {custom_cert};
        ssl_certificate_key {custom_key};
        ssl_session_timeout 1d;
        ssl_session_tickets off;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
    """
            config += self._generate_proxy_block(instance)

        return config

    def _generate_proxy_block(self, instance):
        """Generate the proxy location block (reusable)"""
        return f"""
        # HSTS
        add_header Strict-Transport-Security "max-age=63072000" always;

        # Logging
        access_log /var/log/nginx/ebuilder-{instance.subdomain}-access.log;
        error_log /var/log/nginx/ebuilder-{instance.subdomain}-error.log;

        # Max upload size
        client_max_body_size 100M;

        # Proxy to container
        location / {{
            proxy_pass http://ebuilder_{instance.subdomain};
            proxy_http_version 1.1;

            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket support
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }}

        # Static files
        location /static/ {{
            alias /home/ebuilder/staticfiles/;
            access_log off;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }}

        # Media files
        location /media/ {{
            proxy_pass http://ebuilder_{instance.subdomain};
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-Proto $scheme;
        }}
    }}
    """


def generate_all_configs():
    """
    Regenerate all nginx configs.
    Useful after updates or recovery.
    """
    manager = NginxManager()

    for instance in Instance.objects.filter(status="running"):
        try:
            manager.write_config(instance)
            print(f"Generated config for {instance.subdomain}")
        except Exception as e:
            print(f"Failed for {instance.subdomain}: {e}")

    # Test and reload
    valid, error = manager.test_config()
    if valid:
        manager.reload_nginx()
        print("Nginx reloaded successfully")
    else:
        print(f"Config test failed: {error}")
